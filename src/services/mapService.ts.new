import { supabase } from './supabase';
import { LocationData } from '../types';

interface AssignmentInfo {
  request_id: string;
  request_title: string;
  assignment_id: string;
  assignment_status: string;
  pilgrim_name?: string;
  volunteer_name?: string;
}

interface LocationDetails {
  name: string;
  address: string;
  locality: string;
  landmark?: string;
  placeId?: string;
}

export interface UserLocationData {
  location_id: string;
  user_id: string;
  user_name: string;
  user_role: 'admin' | 'volunteer' | 'pilgrim';
  latitude: number;
  longitude: number;
  accuracy?: number;
  last_updated: string;
  locationDetails?: LocationDetails;
  assignment_info: AssignmentInfo[];
}

interface MapServiceInterface {
  updateUserLocation(location: LocationData): Promise<{ data: any; error: any }>;
  getAssignmentLocations(): Promise<{ data: UserLocationData[] | null; error: any }>;
  subscribeToLocationUpdates(callback: (locations: UserLocationData[]) => void): () => void;
  deactivateUserLocation(): Promise<{ error: any }>;
}

class MapService implements MapServiceInterface {
  private locationSubscription: any = null;

  async updateUserLocation(location: LocationData): Promise<{ data: any; error: any }> {
    try {
      const { data, error } = await supabase.rpc('update_user_location', {
        p_latitude: location.latitude,
        p_longitude: location.longitude,
        p_accuracy: location.accuracy || null,
        p_timestamp: location.timestamp || Date.now(),
      });

      if (error) throw error;
      return { data, error: null };
    } catch (error) {
      console.error('Error updating user location:', error);
      return { data: null, error };
    }
  }

  async getAssignmentLocations(): Promise<{ data: UserLocationData[] | null; error: any }> {
    try {
      const { data: session, error: sessionError } = await supabase.auth.getSession();
      if (sessionError) throw sessionError;

      if (!session?.session?.user) {
        return { data: [], error: null };
      }

      const user = session.session.user;
      const role = user.user_metadata.role;

      let data;
      let error;

      if (role === 'volunteer') {
        ({ data, error } = await supabase.rpc('get_volunteer_assigned_locations', {
          p_volunteer_id: user.id
        }));
      } else if (role === 'pilgrim') {
        ({ data, error } = await supabase.rpc('get_pilgrim_assigned_locations', {
          p_pilgrim_id: user.id
        }));
      }

      if (error) throw error;
      return { data: data || [], error: null };
    } catch (error) {
      console.error('Error getting assignment locations:', error);
      return { data: null, error };
    }
  }

  subscribeToLocationUpdates(callback: (locations: UserLocationData[]) => void): () => void {
    if (this.locationSubscription) {
      this.locationSubscription.unsubscribe();
    }

    this.locationSubscription = supabase
      .channel('location-updates')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'user_locations',
        },
        async () => {
          const { data, error } = await this.getAssignmentLocations();
          if (!error && data) {
            callback(data);
          }
        }
      )
      .subscribe();

    return () => {
      if (this.locationSubscription) {
        this.locationSubscription.unsubscribe();
        this.locationSubscription = null;
      }
    };
  }

  async deactivateUserLocation(): Promise<{ error: any }> {
    try {
      const { error } = await supabase.rpc('deactivate_user_location');
      if (error) throw error;
      return { error: null };
    } catch (error) {
      console.error('Error deactivating user location:', error);
      return { error };
    }
  }
}

// Create and export singleton instance
export const mapService = new MapService();
