import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { locationService } from '../services/locationService';
import { LocationData } from '../types';
import { useAuth } from './AuthContext';
import * as Location from 'expo-location';

interface LocationContextType {
  currentLocation: LocationData | null;
  isTracking: boolean;
  isBackgroundTracking: boolean;
  permissions: { foreground: boolean; background: boolean } | null;
  startTracking: () => Promise<void>;
  stopTracking: () => void;
  getCurrentLocation: () => Promise<LocationData | null>;
  requestPermissions: () => Promise<void>;
}

const LocationContext = createContext<LocationContextType | undefined>(undefined);

export const useLocation = () => {
  const context = useContext(LocationContext);
  if (context === undefined) {
    throw new Error('useLocation must be used within a LocationProvider');
  }
  return context;
};

interface LocationProviderProps {
  children: ReactNode;
}

export const LocationProvider: React.FC<LocationProviderProps> = ({ children }) => {
  const [currentLocation, setCurrentLocation] = useState<LocationData | null>(null);
  const [isTracking, setIsTracking] = useState(false);
  const [isBackgroundTracking, setIsBackgroundTracking] = useState(false);
  const [permissions, setPermissions] = useState<{ foreground: boolean; background: boolean } | null>(null);
  const [watchSubscription, setWatchSubscription] = useState<Location.LocationSubscription | null>(null);
  const { user } = useAuth();

  const requestPermissions = async () => {
    try {
      const perms = await locationService.requestPermissions();
      setPermissions(perms);
      return perms;
    } catch (error) {
      console.error('Error requesting permissions:', error);
      const errorPerms = { foreground: false, background: false };
      setPermissions(errorPerms);
      return errorPerms;
    }
  };

  const getCurrentLocation = async () => {
    try {
      const location = await locationService.getCurrentLocation();
      if (location) {
        setCurrentLocation(location);
      }
      return location;
    } catch (error) {
      console.error('Could not get current location:', error);
      return null;
    }
  };

  const stopTracking = () => {
    try {
      if (watchSubscription) {
        watchSubscription.remove();
        setWatchSubscription(null);
      }
      setIsTracking(false);

      // Stop background tracking if it's running
      locationService.stopBackgroundLocationUpdates()
        .then(() => setIsBackgroundTracking(false))
        .catch(error => console.error('Error stopping background tracking:', error));
    } catch (error) {
      console.error('Error stopping location tracking:', error);
    }
  };

  const startTracking = async () => {
    try {
      if (!permissions?.foreground) {
        const newPerms = await requestPermissions();
        if (!newPerms.foreground) {
          throw new Error('Location permission not granted');
        }
      }

      const subscription = await locationService.watchPosition((location) => {
        setCurrentLocation(location);
      });
      
      if (subscription) {
        setWatchSubscription(subscription);
        setIsTracking(true);
      }

      // Start background updates if we have permission
      if (permissions?.background) {
        try {
          await locationService.startBackgroundLocationUpdates();
          setIsBackgroundTracking(true);
        } catch (error) {
          console.error('Failed to start background tracking:', error);
        }
      }
    } catch (error) {
      console.error('Error starting location tracking:', error);
      throw error;
    }
  };

  useEffect(() => {
    requestPermissions();
  }, []);

  useEffect(() => {
    if (permissions?.foreground) {
      getCurrentLocation();
    }
  }, [permissions]);

  useEffect(() => {
    const autoStartTracking = async () => {
      if (user && permissions?.foreground && !isTracking) {
        console.log('[LocationContext] Auto-starting location tracking for logged-in user');
        await startTracking().catch(error => {
          console.error('Failed to auto-start tracking:', error);
        });
      }
    };

    autoStartTracking();
  }, [user, permissions, isTracking]);

  const value: LocationContextType = {
    currentLocation,
    isTracking,
    isBackgroundTracking,
    permissions,
    startTracking,
    stopTracking,
    getCurrentLocation,
    requestPermissions,
  };

  return (
    <LocationContext.Provider value={value}>
      {children}
    </LocationContext.Provider>
  );
};

export default LocationContext;

interface LocationContextType {
  currentLocation: LocationData | null;
  isTracking: boolean;
  isBackgroundTracking: boolean;
  permissions: { foreground: boolean; background: boolean } | null;
  startTracking: () => Promise<void>;
  stopTracking: () => void;
  getCurrentLocation: () => Promise<LocationData | null>;
  requestPermissions: () => Promise<void>;
}

const LocationContext = createContext<LocationContextType | undefined>(undefined);

interface LocationProviderProps {
  children: ReactNode;
}

export const LocationProvider: React.FC<LocationProviderProps> = ({ children }) => {
  const [currentLocation, setCurrentLocation] = useState<LocationData | null>(null);
  const [isTracking, setIsTracking] = useState(false);
  const [isBackgroundTracking, setIsBackgroundTracking] = useState(false);
  const [permissions, setPermissions] = useState<{ foreground: boolean; background: boolean } | null>(null);
  const [watchSubscription, setWatchSubscription] = useState<Location.LocationSubscription | null>(null);
  const { user } = useAuth();

  const requestPermissions = async () => {
    try {
      const perms = await locationService.requestPermissions();
      setPermissions(perms);
    } catch (error) {
      console.error('Error requesting permissions:', error);
      setPermissions({ foreground: false, background: false });
    }
  };

  const getCurrentLocation = async () => {
    try {
      const location = await locationService.getCurrentLocation();
      if (location) {
        setCurrentLocation(location);
      }
      return location;
    } catch (error) {
      console.error('Could not get current location:', error);
      return null;
    }
  };

  const startTracking = async () => {
    try {
      if (!permissions?.foreground) {
        await requestPermissions();
      }

      if (permissions?.foreground) {
        const subscription = await locationService.watchPosition((location) => {
          setCurrentLocation(location);
        });
        
        if (subscription) {
          setWatchSubscription(subscription);
          setIsTracking(true);
        }
      }
    } catch (error) {
      console.error('Error starting location tracking:', error);
    }
  };

  const stopTracking = () => {
    try {
      if (watchSubscription) {
        watchSubscription.remove();
        setWatchSubscription(null);
      }
      setIsTracking(false);
    } catch (error) {
      console.error('Error stopping location tracking:', error);
    }
  };

  useEffect(() => {
    // Request permissions when component mounts
    requestPermissions();
  }, []);

  useEffect(() => {
    // Get initial location
    getCurrentLocation();
  }, [permissions]);

  // Auto-start tracking for logged in users
  useEffect(() => {
    const autoStartTracking = async () => {
      if (user && permissions?.foreground && !isTracking) {
        console.log('[LocationContext] Auto-starting location tracking for logged-in user');
        await startTracking();
      }
    };

    autoStartTracking();
  }, [user, permissions, isTracking]);

  const contextValue: LocationContextType = {
    currentLocation,
    isTracking,
    isBackgroundTracking,
    permissions,
    startTracking,
    stopTracking,
    getCurrentLocation,
    requestPermissions,
  };

  return (
    <LocationContext.Provider value={contextValue}>
      {children}
    </LocationContext.Provider>
  );

  const requestPermissions = async () => {
    const perms = await locationService.requestPermissions();
    setPermissions(perms);
  };

  const getCurrentLocation = async () => {
    const location = await locationService.getCurrentLocation();
    if (location) {
      setCurrentLocation(location);
    }
    return location;
  };

  const startTracking = async () => {
    try {
      if (!permissions?.foreground) {
        await requestPermissions();
      }

      if (permissions?.foreground) {
        setIsTracking(true);
        const subscription = await locationService.watchPosition((location) => {
          setCurrentLocation(location);
        });
        setWatchSubscription(subscription);
      }
    } catch (error) {
      console.error('Error starting location tracking:', error);
    }
      const subscription = await locationService.watchPosition((location) => {
        setCurrentLocation(location);
      });
      setWatchSubscription(subscription);
      
      // Also start background tracking if permission granted
      if (permissions?.background) {
        const backgroundStarted = await locationService.startBackgroundLocationUpdates();
        setIsBackgroundTracking(backgroundStarted);
      }
    }
  };

  const stopTracking = async () => {
    if (watchSubscription) {
      watchSubscription.remove();
      setWatchSubscription(null);
    }
    setIsTracking(false);
    
    // Stop background tracking
    await locationService.stopBackgroundLocationUpdates();
    setIsBackgroundTracking(false);
  };

  useEffect(() => {
    // Request permissions on mount
    requestPermissions();

    return () => {
      stopTracking();
    };
  }, []);

  useEffect(() => {
    getCurrentLocation();
  }, []);

  // Auto-start tracking when user is logged in and permissions are granted
  useEffect(() => {
    const autoStartTracking = async () => {
      if (user && permissions?.foreground && !isTracking) {
        console.log('[LocationContext] Auto-starting location tracking for logged-in user');
        await startTracking();
      }
    };

    autoStartTracking();
  }, [user, permissions, isTracking]);


  const value: LocationContextType = {
    currentLocation,
    isTracking,
    isBackgroundTracking,
    permissions,
    startTracking,
    stopTracking,
    getCurrentLocation,
    requestPermissions,
  };

  return (
    <LocationContext.Provider value={value}>
      {children}
    </LocationContext.Provider>
  );
};

export const useLocation = (): LocationContextType => {
  const context = useContext(LocationContext);
  if (context === undefined) {
    throw new Error('useLocation must be used within a LocationProvider');
  }
  return context;
};
